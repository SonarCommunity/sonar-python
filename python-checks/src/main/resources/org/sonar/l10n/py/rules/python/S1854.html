<h2>Why is this an issue?</h2>
<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value
only to then overwrite it or throw it away, could indicate a serious error in the code. Even if itâ€™s not an error, it is at best a waste of resources.
Therefore all calculated values should be used.</p>
<h3>Noncompliant code example</h3>
<pre>
def func(a, b, compute):
    i = a + b  # Noncompliant; calculation result not used before value is overwritten
    i = compute()
    return i
</pre>
<h3>Compliant solution</h3>
<pre>
def func(a, b, compute):
    i = a + b
    i += compute()
    return i
</pre>
<h3>Exceptions</h3>
<p>This rule ignores initializations to -1, 0, 1, <code>None</code>, <code>True</code>, <code>False</code> and <code>""</code>.</p>
<p>No issue will be raised on unpacked variables.</p>
<h2>Resources</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/563">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>
</ul>

