import torch
from torch import fx, nn
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

class LeafModuleAwareTracer(fx.Tracer):
    leaf_modules: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def is_leaf_module(self, m: nn.Module, module_qualname: str) -> bool: ...

class NodePathTracer(LeafModuleAwareTracer):
    current_module_qualname: str
    node_to_qualname: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def call_module(self, m: torch.nn.Module, forward: Callable, args, kwargs): ...
    def create_proxy(self, kind: str, target: fx.node.Target, args, kwargs, name: Any | None = ..., type_expr: Any | None = ..., *_) -> fx.proxy.Proxy: ...

def get_graph_node_names(model: nn.Module, tracer_kwargs: Optional[Dict[str, Any]] = ..., suppress_diff_warning: bool = ..., concrete_args: Optional[Dict[str, Any]] = ...) -> Tuple[List[str], List[str]]: ...

class DualGraphModule(fx.GraphModule):
    train_graph: Any
    eval_graph: Any
    graph: Any
    def __init__(self, root: torch.nn.Module, train_graph: fx.Graph, eval_graph: fx.Graph, class_name: str = ...) -> None: ...
    def train(self, mode: bool = ...): ...

def create_feature_extractor(model: nn.Module, return_nodes: Optional[Union[List[str], Dict[str, str]]] = ..., train_return_nodes: Optional[Union[List[str], Dict[str, str]]] = ..., eval_return_nodes: Optional[Union[List[str], Dict[str, str]]] = ..., tracer_kwargs: Optional[Dict[str, Any]] = ..., suppress_diff_warning: bool = ..., concrete_args: Optional[Dict[str, Any]] = ...) -> fx.GraphModule: ...
