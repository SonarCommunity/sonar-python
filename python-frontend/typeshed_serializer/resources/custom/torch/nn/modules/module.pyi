from torch import Tensor, device, dtype
from torch._prims_common import DeviceLikeType
from torch.nn.parameter import Parameter
from torch.utils.hooks import RemovableHandle
from typing import Any, Callable, Dict, Iterator, Mapping, Optional, Set, Tuple, TypeVar, Union, overload
from typing_extensions import Self

T = TypeVar('T', bound='Module')

class _IncompatibleKeys: ...

class _WrappedHook:
    hook: Any
    with_module: bool
    module: Any
    def __init__(self, hook: Callable, module: Optional['Module'] = ...) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

def register_module_buffer_registration_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_module_registration_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_parameter_registration_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_forward_pre_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_forward_hook(hook: Callable[..., None], *, always_call: bool = ...) -> RemovableHandle: ...
def register_module_backward_hook(hook: Callable[[Module, _grad_t, _grad_t], Union[None, _grad_t]]) -> RemovableHandle: ...
def register_module_full_backward_pre_hook(hook: Callable[[Module, _grad_t], Union[None, _grad_t]]) -> RemovableHandle: ...
def register_module_full_backward_hook(hook: Callable[[Module, _grad_t, _grad_t], Union[None, _grad_t]]) -> RemovableHandle: ...

class Module:
    dump_patches: bool
    training: bool
    call_super_init: bool
    def __init__(self, *args, **kwargs) -> None: ...
    forward: Callable[..., Any]
    def register_buffer(self, name: str, tensor: Optional[Tensor], persistent: bool = ...) -> None: ...
    def register_parameter(self, name: str, param: Optional[Parameter]) -> None: ...
    def add_module(self, name: str, module: Optional['Module']) -> None: ...
    def register_module(self, name: str, module: Optional['Module']) -> None: ...
    def get_submodule(self, target: str) -> Module: ...
    def set_submodule(self, target: str, module: Module) -> None: ...
    def get_parameter(self, target: str) -> Parameter: ...
    def get_buffer(self, target: str) -> Tensor: ...
    def get_extra_state(self) -> Any: ...
    def set_extra_state(self, state: Any) -> None: ...
    def apply(self, fn: Callable[[Module], None]) -> T: ...
    def cuda(self, device: Optional[Union[int, device]] = ...) -> T: ...
    def ipu(self, device: Optional[Union[int, device]] = ...) -> T: ...
    def xpu(self, device: Optional[Union[int, device]] = ...) -> T: ...
    def mtia(self, device: Optional[Union[int, device]] = ...) -> T: ...
    def cpu(self) -> T: ...
    def type(self, dst_type: Union[dtype, str]) -> T: ...
    def float(self) -> T: ...
    def double(self) -> T: ...
    def half(self) -> T: ...
    def bfloat16(self) -> T: ...
    def to_empty(self, *, device: Optional[DeviceLikeType], recurse: bool = ...) -> T: ...
    @overload
    def to(self, device: Optional[DeviceLikeType] = ..., dtype: Optional[dtype] = ..., non_blocking: bool = ...) -> Self: ...
    @overload
    def to(self, dtype: dtype, non_blocking: bool = ...) -> Self: ...
    @overload
    def to(self, tensor: Tensor, non_blocking: bool = ...) -> Self: ...
    def register_full_backward_pre_hook(self, hook: Callable[[Module, _grad_t], Union[None, _grad_t]], prepend: bool = ...) -> RemovableHandle: ...
    def register_backward_hook(self, hook: Callable[[Module, _grad_t, _grad_t], Union[None, _grad_t]]) -> RemovableHandle: ...
    def register_full_backward_hook(self, hook: Callable[[Module, _grad_t, _grad_t], Union[None, _grad_t]], prepend: bool = ...) -> RemovableHandle: ...
    def register_forward_pre_hook(self, hook: Union[Callable[[T, Tuple[Any, ...]], Optional[Any]], Callable[[T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = ..., with_kwargs: bool = ...) -> RemovableHandle: ...
    def register_forward_hook(self, hook: Union[Callable[[T, Tuple[Any, ...], Any], Optional[Any]], Callable[[T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = ..., with_kwargs: bool = ..., always_call: bool = ...) -> RemovableHandle: ...
    __call__: Callable[..., Any]
    def __getattr__(self, name: str) -> Any: ...
    def __setattr__(self, name: str, value: Union[Tensor, 'Module']) -> None: ...
    def __delattr__(self, name) -> None: ...
    def register_state_dict_post_hook(self, hook): ...
    def register_state_dict_pre_hook(self, hook): ...
    T_destination: Any
    @overload
    def state_dict(self, *, destination: T_destination, prefix: str = ..., keep_vars: bool = ...) -> T_destination: ...
    @overload
    def state_dict(self, *, prefix: str = ..., keep_vars: bool = ...) -> Dict[str, Any]: ...
    def register_load_state_dict_pre_hook(self, hook): ...
    def register_load_state_dict_post_hook(self, hook): ...
    def load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = ..., assign: bool = ...): ...
    def parameters(self, recurse: bool = ...) -> Iterator[Parameter]: ...
    def named_parameters(self, prefix: str = ..., recurse: bool = ..., remove_duplicate: bool = ...) -> Iterator[Tuple[str, Parameter]]: ...
    def buffers(self, recurse: bool = ...) -> Iterator[Tensor]: ...
    def named_buffers(self, prefix: str = ..., recurse: bool = ..., remove_duplicate: bool = ...) -> Iterator[Tuple[str, Tensor]]: ...
    def children(self) -> Iterator['Module']: ...
    def named_children(self) -> Iterator[Tuple[str, 'Module']]: ...
    def modules(self) -> Iterator['Module']: ...
    def named_modules(self, memo: Optional[Set['Module']] = ..., prefix: str = ..., remove_duplicate: bool = ...): ...
    def train(self, mode: bool = ...) -> T: ...
    def eval(self) -> T: ...
    def requires_grad_(self, requires_grad: bool = ...) -> T: ...
    def zero_grad(self, set_to_none: bool = ...) -> None: ...
    def share_memory(self) -> T: ...
    def extra_repr(self) -> str: ...
    def __dir__(self): ...
    def compile(self, *args, **kwargs) -> None: ...
