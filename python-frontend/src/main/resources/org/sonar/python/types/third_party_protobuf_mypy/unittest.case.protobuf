
unittest.case§
AbstractSettyping.AbstractSet"typing.Collection*ä
__contains__typing.AbstractSet.__contains__"
builtins.bool"builtins.bool*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*$"
builtins.object"builtins.object0:abstractmethod@*…
_hashtyping.AbstractSet._hash"
builtins.int"builtins.int*á
self}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*˛
__le__typing.AbstractSet.__le__"
builtins.bool"builtins.bool*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*86
typing.AbstractSet[Any]
Any"typing.AbstractSet*˛
__lt__typing.AbstractSet.__lt__"
builtins.bool"builtins.bool*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*86
typing.AbstractSet[Any]
Any"typing.AbstractSet*˛
__gt__typing.AbstractSet.__gt__"
builtins.bool"builtins.bool*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*86
typing.AbstractSet[Any]
Any"typing.AbstractSet*˛
__ge__typing.AbstractSet.__ge__"
builtins.bool"builtins.bool*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*86
typing.AbstractSet[Any]
Any"typing.AbstractSet*ﬂ
__and__typing.AbstractSet.__and__"}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*86
typing.AbstractSet[Any]
Any"typing.AbstractSet*ò
__or__typing.AbstractSet.__or__"ˆ
1typing.AbstractSet[Union[typing._T_co,typing._T]]¨
Union[typing._T_co,typing._T]E
typing._T_co"
builtins.object"builtins.object"builtins.objectB
	typing._T"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*yw
typing.AbstractSet[typing._T]B
	typing._T"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*ﬂ
__sub__typing.AbstractSet.__sub__"}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*86
typing.AbstractSet[Any]
Any"typing.AbstractSet*ö
__xor__typing.AbstractSet.__xor__"ˆ
1typing.AbstractSet[Union[typing._T_co,typing._T]]¨
Union[typing._T_co,typing._T]E
typing._T_co"
builtins.object"builtins.object"builtins.objectB
	typing._T"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*yw
typing.AbstractSet[typing._T]B
	typing._T"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*í

isdisjointtyping.AbstractSet.isdisjoint"
builtins.bool"builtins.bool*á
self}
 typing.AbstractSet[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.AbstractSet*;
other0
typing.Iterable[Any]
Any"typing.IterableP§
_BaseTestCaseContext"unittest.case._BaseTestCaseContext"builtins.object*÷
__init__+unittest.case._BaseTestCaseContext.__init__"
None*R
selfH
"unittest.case._BaseTestCaseContext""unittest.case._BaseTestCaseContext*?
	test_case0
unittest.case.TestCase"unittest.case.TestCase‡ 
_LoggingWatcherunittest.case._LoggingWatcher"builtins.tuple*¥
_replace&unittest.case._LoggingWatcher._replace"ñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*¢
_selfñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*h
recordsY
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.list *X
outputJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list *€
__new__%unittest.case._LoggingWatcher.__new__"ñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*œ
_clsƒ
'Type[unittest.case._LoggingWatcher._NT]ñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*f
recordsY
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.list*V
outputJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*Æ
_asdict%unittest.case._LoggingWatcher._asdict"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*¢
_selfñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*ê
_make#unittest.case._LoggingWatcher._make"ñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*œ
_clsƒ
'Type[unittest.case._LoggingWatcher._NT]ñ
!unittest.case._LoggingWatcher._NTÓ
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*>
iterable0
typing.Iterable[Any]
Any"typing.Iterable*
new
Any *
len
Any 0:classmethodprã
records%unittest.case._LoggingWatcher.recordsY
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listrz
output$unittest.case._LoggingWatcher.outputJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listrã
records%unittest.case._LoggingWatcher.recordsY
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listrz
output$unittest.case._LoggingWatcher.outputJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listrí
_fields%unittest.case._LoggingWatcher._fields`
 Tuple[builtins.str,builtins.str]
builtins.str"builtins.str
builtins.str"builtins.strrì
_field_types*unittest.case._LoggingWatcher._field_typesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictrô
_field_defaults-unittest.case._LoggingWatcher._field_defaultsW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictrN
_source%unittest.case._LoggingWatcher._source
builtins.str"builtins.strrô
__annotations__-unittest.case._LoggingWatcher.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict‘
_AssertLogsContext unittest.case._AssertLogsContext""unittest.case._BaseTestCaseContext*á
__init__)unittest.case._AssertLogsContext.__init__"
None*¨
self°
2unittest.case._AssertLogsContext[unittest.case._L]I
unittest.case._L"
builtins.object"builtins.object"builtins.object" unittest.case._AssertLogsContext*?
	test_case0
unittest.case.TestCase"unittest.case.TestCase*-
logger_name
builtins.str"builtins.str*'
level
builtins.int"builtins.int*√
	__enter__*unittest.case._AssertLogsContext.__enter__"‚
NTypeAlias[Tuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]]Ó
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list"unittest.case._LoggingWatcher*§°
2unittest.case._AssertLogsContext[unittest.case._L]I
unittest.case._L"
builtins.object"builtins.object"builtins.object" unittest.case._AssertLogsContext*¯
__exit__)unittest.case._AssertLogsContext.__exit__"G
Union[builtins.bool,None]
builtins.bool"builtins.bool
None*§°
2unittest.case._AssertLogsContext[unittest.case._L]I
unittest.case._L"
builtins.object"builtins.object"builtins.object" unittest.case._AssertLogsContext*çä
(Union[Type[builtins.BaseException],None]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException
None*db
"Union[builtins.BaseException,None]0
builtins.BaseException"builtins.BaseException
None*[Y
Union[types.TracebackType,None]*
types.TracebackType"types.TracebackType
NonePr_
LOGGING_FORMAT/unittest.case._AssertLogsContext.LOGGING_FORMAT
builtins.str"builtins.strri
	test_case*unittest.case._AssertLogsContext.test_case0
unittest.case.TestCase"unittest.case.TestCaserY
logger_name,unittest.case._AssertLogsContext.logger_name
builtins.str"builtins.strrM
level&unittest.case._AssertLogsContext.level
builtins.int"builtins.intr5
msg$unittest.case._AssertLogsContext.msg
None‘
SkipTestunittest.case.SkipTest"builtins.Exception*õ
__init__unittest.case.SkipTest.__init__"
None*:
self0
unittest.case.SkipTest"unittest.case.SkipTest*(
reason
builtins.str"builtins.strr
_SupportsAbsAndDunderGE%unittest.case._SupportsAbsAndDunderGE"_typeshed.SupportsDunderGE"typing.SupportsAbsX·Ê
TestCaseunittest.case.TestCase"builtins.object*°
__init__unittest.case.TestCase.__init__"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*.

methodName
builtins.str"builtins.str *°
__eq__unittest.case.TestCase.__eq__"
builtins.bool"builtins.bool*20
unittest.case.TestCase"unittest.case.TestCase*$"
builtins.object"builtins.object*k
setUpunittest.case.TestCase.setUp"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*q
tearDownunittest.case.TestCase.tearDown"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ß

setUpClass!unittest.case.TestCase.setUpClass"
None*[
clsR
Type[unittest.case.TestCase]0
unittest.case.TestCase"unittest.case.TestCase0:classmethodp*≠
tearDownClass$unittest.case.TestCase.tearDownClass"
None*[
clsR
Type[unittest.case.TestCase]0
unittest.case.TestCase"unittest.case.TestCase0:classmethodp*À
rununittest.case.TestCase.run"n
&Union[unittest.result.TestResult,None]8
unittest.result.TestResult"unittest.result.TestResult
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*|
resultn
&Union[unittest.result.TestResult,None]8
unittest.result.TestResult"unittest.result.TestResult
None *’
__call__unittest.case.TestCase.__call__"n
&Union[unittest.result.TestResult,None]8
unittest.result.TestResult"unittest.result.TestResult
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*|
resultn
&Union[unittest.result.TestResult,None]8
unittest.result.TestResult"unittest.result.TestResult
None *ä
skipTestunittest.case.TestCase.skipTest"
NoReturn
*:
self0
unittest.case.TestCase"unittest.case.TestCase*
reason
Any*Ê
subTestunittest.case.TestCase.subTest"V
'contextlib.AbstractContextManager[None]
None"!contextlib.AbstractContextManager*:
self0
unittest.case.TestCase"unittest.case.TestCase*
msg
Any *
params
Any*k
debugunittest.case.TestCase.debug"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*¢
_addSkipunittest.case.TestCase._addSkip"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*D
result8
unittest.result.TestResult"unittest.result.TestResult*?
	test_case0
unittest.case.TestCase"unittest.case.TestCase*(
reason
builtins.str"builtins.str*¥
assertEqual"unittest.case.TestCase.assertEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*
first
Any*
second
Any*
msg
Any *∫
assertNotEqual%unittest.case.TestCase.assertNotEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*
first
Any*
second
Any*
msg
Any *ú

assertTrue!unittest.case.TestCase.assertTrue"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*
expr
Any*
msg
Any *û
assertFalse"unittest.case.TestCase.assertFalse"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*
expr
Any*
msg
Any *„
assertIsunittest.case.TestCase.assertIs"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*-
expr1"
builtins.object"builtins.object*-
expr2"
builtins.object"builtins.object*
msg
Any *È
assertIsNot"unittest.case.TestCase.assertIsNot"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*-
expr1"
builtins.object"builtins.object*-
expr2"
builtins.object"builtins.object*
msg
Any *∫
assertIsNone#unittest.case.TestCase.assertIsNone"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*+
obj"
builtins.object"builtins.object*
msg
Any *¿
assertIsNotNone&unittest.case.TestCase.assertIsNotNone"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*+
obj"
builtins.object"builtins.object*
msg
Any *»
assertInunittest.case.TestCase.assertIn"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*
member
Any*´
	containerõ
1Union[typing.Iterable[Any],typing.Container[Any]]0
typing.Iterable[Any]
Any"typing.Iterable2
typing.Container[Any]
Any"typing.Container*
msg
Any *Œ
assertNotIn"unittest.case.TestCase.assertNotIn"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*
member
Any*´
	containerõ
1Union[typing.Iterable[Any],typing.Container[Any]]0
typing.Iterable[Any]
Any"typing.Iterable2
typing.Container[Any]
Any"typing.Container*
msg
Any *£
assertIsInstance'unittest.case.TestCase.assertIsInstance"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*+
obj"
builtins.object"builtins.object*ﬁ
cls‘
7TypeAlias[Union[builtins.type,builtins.tuple[Unknown]]]}
,Union[builtins.type,builtins.tuple[Unknown]]
builtins.type"builtins.type+
builtins.tuple[Unknown] "builtins.tuple"unittest.case._ClassInfo*
msg
Any *©
assertNotIsInstance*unittest.case.TestCase.assertNotIsInstance"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*+
obj"
builtins.object"builtins.object*ﬁ
cls‘
7TypeAlias[Union[builtins.type,builtins.tuple[Unknown]]]}
,Union[builtins.type,builtins.tuple[Unknown]]
builtins.type"builtins.type+
builtins.tuple[Unknown] "builtins.tuple"unittest.case._ClassInfo*
msg
Any *Î

assertLogs!unittest.case.TestCase.assertLogs"˘
punittest.case._AssertLogsContext[TypeAlias[Tuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]]]‚
NTypeAlias[Tuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]]Ó
CTuple[builtins.list[logging.LogRecord],builtins.list[builtins.str]]Y
 builtins.list[logging.LogRecord]&
logging.LogRecord"logging.LogRecord"builtins.listJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list"unittest.case._LoggingWatcher" unittest.case._AssertLogsContext*:
self0
unittest.case.TestCase"unittest.case.TestCase*É
loggeru
'Union[builtins.str,logging.Logger,None]
builtins.str"builtins.str 
logging.Logger"logging.Logger
None *|
levelo
%Union[builtins.int,builtins.str,None]
builtins.int"builtins.int
builtins.str"builtins.str
None *‡
assertRegex"unittest.case.TestCase.assertRegex"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*P
textF
typing.AnyStr"
builtins.object"builtins.object"builtins.object*Ä
expected_regexÎ
.Union[typing.AnyStr,re.Pattern[typing.AnyStr]]F
typing.AnyStr"
builtins.object"builtins.object"builtins.objecto
re.Pattern[typing.AnyStr]F
typing.AnyStr"
builtins.object"builtins.object"builtins.object"
re.Pattern*
msg
Any *Ë
assertNotRegex%unittest.case.TestCase.assertNotRegex"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*P
textF
typing.AnyStr"
builtins.object"builtins.object"builtins.object*Ç
unexpected_regexÎ
.Union[typing.AnyStr,re.Pattern[typing.AnyStr]]F
typing.AnyStr"
builtins.object"builtins.object"builtins.objecto
re.Pattern[typing.AnyStr]F
typing.AnyStr"
builtins.object"builtins.object"builtins.object"
re.Pattern*
msg
Any *ê
assertCountEqual'unittest.case.TestCase.assertCountEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*;
first0
typing.Iterable[Any]
Any"typing.Iterable*<
second0
typing.Iterable[Any]
Any"typing.Iterable*
msg
Any *á
addTypeEqualityFunc*unittest.case.TestCase.addTypeEqualityFunc"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*#
typeobj
	Type[Any]
Any*Y
functionK
CallableType[builtins.function]&
builtins.function"builtins.function*
assertMultiLineEqual+unittest.case.TestCase.assertMultiLineEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*'
first
builtins.str"builtins.str*(
second
builtins.str"builtins.str*
msg
Any *≠
assertSequenceEqual*unittest.case.TestCase.assertSequenceEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*:
seq10
typing.Sequence[Any]
Any"typing.Sequence*:
seq20
typing.Sequence[Any]
Any"typing.Sequence*
msg
Any *ó
seq_typeÜ
&Union[Type[typing.Sequence[Any]],None]P
Type[typing.Sequence[Any]]0
typing.Sequence[Any]
Any"typing.Sequence
None *Ö
assertListEqual&unittest.case.TestCase.assertListEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*7
list1,
builtins.list[Any]
Any"builtins.list*7
list2,
builtins.list[Any]
Any"builtins.list*
msg
Any *ç
assertTupleEqual'unittest.case.TestCase.assertTupleEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*:
tuple1.
builtins.tuple[Any]
Any"builtins.tuple*:
tuple2.
builtins.tuple[Any]
Any"builtins.tuple*
msg
Any *„
assertSetEqual%unittest.case.TestCase.assertSetEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*g
set1]
#typing.AbstractSet[builtins.object]"
builtins.object"builtins.object"typing.AbstractSet*g
set2]
#typing.AbstractSet[builtins.object]"
builtins.object"builtins.object"typing.AbstractSet*
msg
Any *Î
assertDictEqual&unittest.case.TestCase.assertDictEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*j
d1b
#typing.Mapping[Any,builtins.object]
Any"
builtins.object"builtins.object"typing.Mapping*j
d2b
#typing.Mapping[Any,builtins.object]
Any"
builtins.object"builtins.object"typing.Mapping*
msg
Any *Å
failunittest.case.TestCase.fail"
NoReturn
*:
self0
unittest.case.TestCase"unittest.case.TestCase*
msg
Any *ë
countTestCases%unittest.case.TestCase.countTestCases"
builtins.int"builtins.int*:
self0
unittest.case.TestCase"unittest.case.TestCase*≥
defaultTestResult(unittest.case.TestCase.defaultTestResult"8
unittest.result.TestResult"unittest.result.TestResult*:
self0
unittest.case.TestCase"unittest.case.TestCase*y
idunittest.case.TestCase.id"
builtins.str"builtins.str*:
self0
unittest.case.TestCase"unittest.case.TestCase*Ω
shortDescription'unittest.case.TestCase.shortDescription"D
Union[builtins.str,None]
builtins.str"builtins.str
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ﬁ

addCleanup!unittest.case.TestCase.addCleanup"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*MK
CallableType[builtins.function]&
builtins.function"builtins.function*

args *
kwargs *u

doCleanups!unittest.case.TestCase.doCleanups"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ö
addClassCleanup&unittest.case.TestCase.addClassCleanup"
None*[
clsR
Type[unittest.case.TestCase]0
unittest.case.TestCase"unittest.case.TestCase*MK
CallableType[builtins.function]&
builtins.function"builtins.function*

args *
kwargs 0:classmethodp*±
doClassCleanups&unittest.case.TestCase.doClassCleanups"
None*[
clsR
Type[unittest.case.TestCase]0
unittest.case.TestCase"unittest.case.TestCase0:classmethodp*è
_formatMessage%unittest.case.TestCase._formatMessage"
builtins.str"builtins.str*:
self0
unittest.case.TestCase"unittest.case.TestCase*M
msgD
Union[builtins.str,None]
builtins.str"builtins.str
None*-
standardMsg
builtins.str"builtins.str*˘
_getAssertEqualityFunc-unittest.case.TestCase._getAssertEqualityFunc"K
CallableType[builtins.function]&
builtins.function"builtins.function*:
self0
unittest.case.TestCase"unittest.case.TestCase*
first
Any*
second
Any*÷
assertDictContainsSubset/unittest.case.TestCase.assertDictContainsSubset"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*G
subset;
typing.Mapping[Any,Any]
Any
Any"typing.Mapping*K

dictionary;
typing.Mapping[Any,Any]
Any
Any"typing.Mapping*-
msg"
builtins.object"builtins.object 2Ÿ
assertGreater$unittest.case.TestCase.assertGreaterè
assertGreater$unittest.case.TestCase.assertGreater"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
aï
,_typeshed.SupportsDunderGT[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderGT*P
bI
unittest.case._T"
builtins.object"builtins.object"builtins.object*
msg
Any 0:overloadXè
assertGreater$unittest.case.TestCase.assertGreater"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*P
aI
unittest.case._T"
builtins.object"builtins.object"builtins.object*ù
bï
,_typeshed.SupportsDunderLT[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderLT*
msg
Any 0:overloadX2˜
assertGreaterEqual)unittest.case.TestCase.assertGreaterEqualô
assertGreaterEqual)unittest.case.TestCase.assertGreaterEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
aï
,_typeshed.SupportsDunderGE[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderGE*P
bI
unittest.case._T"
builtins.object"builtins.object"builtins.object*
msg
Any 0:overloadXô
assertGreaterEqual)unittest.case.TestCase.assertGreaterEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*P
aI
unittest.case._T"
builtins.object"builtins.object"builtins.object*ù
bï
,_typeshed.SupportsDunderLE[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderLE*
msg
Any 0:overloadX2«

assertLess!unittest.case.TestCase.assertLessâ

assertLess!unittest.case.TestCase.assertLess"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
aï
,_typeshed.SupportsDunderLT[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderLT*P
bI
unittest.case._T"
builtins.object"builtins.object"builtins.object*
msg
Any 0:overloadXâ

assertLess!unittest.case.TestCase.assertLess"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*P
aI
unittest.case._T"
builtins.object"builtins.object"builtins.object*ù
bï
,_typeshed.SupportsDunderGT[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderGT*
msg
Any 0:overloadX2Â
assertLessEqual&unittest.case.TestCase.assertLessEqualì
assertLessEqual&unittest.case.TestCase.assertLessEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
aï
,_typeshed.SupportsDunderLT[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderLT*P
bI
unittest.case._T"
builtins.object"builtins.object"builtins.object*
msg
Any 0:overloadXì
assertLessEqual&unittest.case.TestCase.assertLessEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*P
aI
unittest.case._T"
builtins.object"builtins.object"builtins.object*ù
bï
,_typeshed.SupportsDunderGT[unittest.case._T]I
unittest.case._T"
builtins.object"builtins.object"builtins.object"_typeshed.SupportsDunderGT*
msg
Any 0:overloadX2Å
assertRaises#unittest.case.TestCase.assertRaises„
assertRaises#unittest.case.TestCase.assertRaises"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*÷
expected_exceptionΩ
PUnion[Type[builtins.BaseException],builtins.tuple[Type[builtins.BaseException]]]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseExceptioní
,builtins.tuple[Type[builtins.BaseException]]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException"builtins.tuple*Y
callableK
CallableType[builtins.function]&
builtins.function"builtins.function*
args
Any*
kwargs
Any0:overloadXÂ
assertRaises#unittest.case.TestCase.assertRaises"∫
4unittest.case._AssertRaisesContext[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException""unittest.case._AssertRaisesContext*:
self0
unittest.case.TestCase"unittest.case.TestCase*î
expected_exception˚
DUnion[Type[unittest.case._E],builtins.tuple[Type[unittest.case._E]]]z
Type[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException¥
&builtins.tuple[Type[unittest.case._E]]z
Type[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException"builtins.tuple*
msg
Any 0:overloadX2˜
assertRaisesRegex(unittest.case.TestCase.assertRaisesRegexô
assertRaisesRegex(unittest.case.TestCase.assertRaisesRegex"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*÷
expected_exceptionΩ
PUnion[Type[builtins.BaseException],builtins.tuple[Type[builtins.BaseException]]]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseExceptioní
,builtins.tuple[Type[builtins.BaseException]]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException"builtins.tuple*©
expected_regexî
,Union[builtins.str,re.Pattern[builtins.str]]
builtins.str"builtins.strD
re.Pattern[builtins.str]
builtins.str"builtins.str"
re.Pattern*Y
callableK
CallableType[builtins.function]&
builtins.function"builtins.function*
args
Any*
kwargs
Any0:overloadXõ
assertRaisesRegex(unittest.case.TestCase.assertRaisesRegex"∫
4unittest.case._AssertRaisesContext[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException""unittest.case._AssertRaisesContext*:
self0
unittest.case.TestCase"unittest.case.TestCase*î
expected_exception˚
DUnion[Type[unittest.case._E],builtins.tuple[Type[unittest.case._E]]]z
Type[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException¥
&builtins.tuple[Type[unittest.case._E]]z
Type[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException"builtins.tuple*©
expected_regexî
,Union[builtins.str,re.Pattern[builtins.str]]
builtins.str"builtins.strD
re.Pattern[builtins.str]
builtins.str"builtins.str"
re.Pattern*
msg
Any 0:overloadX2»
assertWarns"unittest.case.TestCase.assertWarnsö
assertWarns"unittest.case.TestCase.assertWarns"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
expected_warningÜ
DUnion[Type[builtins.Warning],builtins.tuple[Type[builtins.Warning]]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warningz
&builtins.tuple[Type[builtins.Warning]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warning"builtins.tuple*Y
callableK
CallableType[builtins.function]&
builtins.function"builtins.function*

args *
kwargs 0:overloadX˜
assertWarns"unittest.case.TestCase.assertWarns"F
!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
expected_warningÜ
DUnion[Type[builtins.Warning],builtins.tuple[Type[builtins.Warning]]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warningz
&builtins.tuple[Type[builtins.Warning]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warning"builtins.tuple*
msg
Any 0:overloadX2æ
assertWarnsRegex'unittest.case.TestCase.assertWarnsRegex–
assertWarnsRegex'unittest.case.TestCase.assertWarnsRegex"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
expected_warningÜ
DUnion[Type[builtins.Warning],builtins.tuple[Type[builtins.Warning]]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warningz
&builtins.tuple[Type[builtins.Warning]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warning"builtins.tuple*©
expected_regexî
,Union[builtins.str,re.Pattern[builtins.str]]
builtins.str"builtins.strD
re.Pattern[builtins.str]
builtins.str"builtins.str"
re.Pattern*Y
callableK
CallableType[builtins.function]&
builtins.function"builtins.function*

args *
kwargs 0:overloadX≠
assertWarnsRegex'unittest.case.TestCase.assertWarnsRegex"F
!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext*:
self0
unittest.case.TestCase"unittest.case.TestCase*ù
expected_warningÜ
DUnion[Type[builtins.Warning],builtins.tuple[Type[builtins.Warning]]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warningz
&builtins.tuple[Type[builtins.Warning]]@
Type[builtins.Warning]$
builtins.Warning"builtins.Warning"builtins.tuple*©
expected_regexî
,Union[builtins.str,re.Pattern[builtins.str]]
builtins.str"builtins.strD
re.Pattern[builtins.str]
builtins.str"builtins.str"
re.Pattern*
msg
Any 0:overloadX2È
assertAlmostEqual(unittest.case.TestCase.assertAlmostEqualù
assertAlmostEqual(unittest.case.TestCase.assertAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*Å
firstv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*Ç
secondv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*
places
None*
msg
Any*Y
deltaN
%unittest.case._SupportsAbsAndDunderGE"%unittest.case._SupportsAbsAndDunderGE0:overloadX°
assertAlmostEqual(unittest.case.TestCase.assertAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*Å
firstv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*Ç
secondv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*
places
None *
msg
Any *Y
deltaN
%unittest.case._SupportsAbsAndDunderGE"%unittest.case._SupportsAbsAndDunderGE0:overloadX
assertAlmostEqual(unittest.case.TestCase.assertAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*Ü
first˙
a_typeshed.SupportsSub[unittest.case._T,typing.SupportsAbs[typing.SupportsRound[builtins.object]]]I
unittest.case._T"
builtins.object"builtins.object"builtins.object≤
9typing.SupportsAbs[typing.SupportsRound[builtins.object]]a
%typing.SupportsRound[builtins.object]"
builtins.object"builtins.object"typing.SupportsRound"typing.SupportsAbs"_typeshed.SupportsSub*U
secondI
unittest.case._T"
builtins.object"builtins.object"builtins.object*R
placesD
Union[builtins.int,None]
builtins.int"builtins.int
None *
msg
Any *
delta
None 0:overloadXÚ
assertAlmostEqual(unittest.case.TestCase.assertAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*T
firstI
unittest.case._T"
builtins.object"builtins.object"builtins.object*â
second¸
b_typeshed.SupportsRSub[unittest.case._T,typing.SupportsAbs[typing.SupportsRound[builtins.object]]]I
unittest.case._T"
builtins.object"builtins.object"builtins.object≤
9typing.SupportsAbs[typing.SupportsRound[builtins.object]]a
%typing.SupportsRound[builtins.object]"
builtins.object"builtins.object"typing.SupportsRound"typing.SupportsAbs"_typeshed.SupportsRSub*R
placesD
Union[builtins.int,None]
builtins.int"builtins.int
None *
msg
Any *
delta
None 0:overloadX2á
assertNotAlmostEqual+unittest.case.TestCase.assertNotAlmostEqual£
assertNotAlmostEqual+unittest.case.TestCase.assertNotAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*Å
firstv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*Ç
secondv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*
places
None*
msg
Any*Y
deltaN
%unittest.case._SupportsAbsAndDunderGE"%unittest.case._SupportsAbsAndDunderGE0:overloadXß
assertNotAlmostEqual+unittest.case.TestCase.assertNotAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*Å
firstv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*Ç
secondv
unittest.case._SI
_typeshed.SupportsSub[Any,Any]
Any
Any"_typeshed.SupportsSub"_typeshed.SupportsSub*
places
None *
msg
Any *Y
deltaN
%unittest.case._SupportsAbsAndDunderGE"%unittest.case._SupportsAbsAndDunderGE0:overloadXˆ
assertNotAlmostEqual+unittest.case.TestCase.assertNotAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*Ü
first˙
a_typeshed.SupportsSub[unittest.case._T,typing.SupportsAbs[typing.SupportsRound[builtins.object]]]I
unittest.case._T"
builtins.object"builtins.object"builtins.object≤
9typing.SupportsAbs[typing.SupportsRound[builtins.object]]a
%typing.SupportsRound[builtins.object]"
builtins.object"builtins.object"typing.SupportsRound"typing.SupportsAbs"_typeshed.SupportsSub*U
secondI
unittest.case._T"
builtins.object"builtins.object"builtins.object*R
placesD
Union[builtins.int,None]
builtins.int"builtins.int
None *
msg
Any *
delta
None 0:overloadX¯
assertNotAlmostEqual+unittest.case.TestCase.assertNotAlmostEqual"
None*:
self0
unittest.case.TestCase"unittest.case.TestCase*T
firstI
unittest.case._T"
builtins.object"builtins.object"builtins.object*â
second¸
b_typeshed.SupportsRSub[unittest.case._T,typing.SupportsAbs[typing.SupportsRound[builtins.object]]]I
unittest.case._T"
builtins.object"builtins.object"builtins.object≤
9typing.SupportsAbs[typing.SupportsRound[builtins.object]]a
%typing.SupportsRound[builtins.object]"
builtins.object"builtins.object"typing.SupportsRound"typing.SupportsAbs"_typeshed.SupportsRSub*R
placesD
Union[builtins.int,None]
builtins.int"builtins.int
None *
msg
Any *
delta
None 0:overloadXrè
failureException'unittest.case.TestCase.failureExceptionR
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseExceptionrQ
longMessage"unittest.case.TestCase.longMessage
builtins.bool"builtins.boolro
maxDiffunittest.case.TestCase.maxDiffD
Union[builtins.int,None]
builtins.int"builtins.int
NonerW
_testMethodName&unittest.case.TestCase._testMethodName
builtins.str"builtins.strrU
_testMethodDoc%unittest.case.TestCase._testMethodDoc
builtins.str"builtins.strrÜ
failUnlessEqual&unittest.case.TestCase.failUnlessEqualK
CallableType[builtins.function]&
builtins.function"builtins.functionrÄ
assertEquals#unittest.case.TestCase.assertEqualsK
CallableType[builtins.function]&
builtins.function"builtins.functionr~
failIfEqual"unittest.case.TestCase.failIfEqualK
CallableType[builtins.function]&
builtins.function"builtins.functionrÜ
assertNotEquals&unittest.case.TestCase.assertNotEqualsK
CallableType[builtins.function]&
builtins.function"builtins.functionr|

failUnless!unittest.case.TestCase.failUnlessK
CallableType[builtins.function]&
builtins.function"builtins.functionrv
assert_unittest.case.TestCase.assert_K
CallableType[builtins.function]&
builtins.function"builtins.functionrt
failIfunittest.case.TestCase.failIfK
CallableType[builtins.function]&
builtins.function"builtins.functionrõ
failUnlessRaises'unittest.case.TestCase.failUnlessRaises^
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.functionr•
failUnlessAlmostEqual,unittest.case.TestCase.failUnlessAlmostEqual^
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.functionrü
assertAlmostEquals)unittest.case.TestCase.assertAlmostEquals^
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.functionrù
failIfAlmostEqual(unittest.case.TestCase.failIfAlmostEqual^
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.functionr•
assertNotAlmostEquals,unittest.case.TestCase.assertNotAlmostEquals^
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.functionré
assertRegexpMatches*unittest.case.TestCase.assertRegexpMatchesK
CallableType[builtins.function]&
builtins.function"builtins.functionrî
assertNotRegexpMatches-unittest.case.TestCase.assertNotRegexpMatchesK
CallableType[builtins.function]&
builtins.function"builtins.functionrü
assertRaisesRegexp)unittest.case.TestCase.assertRaisesRegexp^
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.function≈
FunctionTestCaseunittest.case.FunctionTestCase"unittest.case.TestCase*Ó
__init__'unittest.case.FunctionTestCase.__init__"
None*J
self@
unittest.case.FunctionTestCase"unittest.case.FunctionTestCase*Y
testFuncK
CallableType[builtins.function]&
builtins.function"builtins.function*î
setUpÜ
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
None *ó
tearDownÜ
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
None *W
descriptionD
Union[builtins.str,None]
builtins.str"builtins.str
None *á
runTest&unittest.case.FunctionTestCase.runTest"
None*J
self@
unittest.case.FunctionTestCase"unittest.case.FunctionTestCase≥
_AssertRaisesContext"unittest.case._AssertRaisesContext"builtins.object*⁄
	__enter__,unittest.case._AssertRaisesContext.__enter__"å
'unittest.case._AssertRaisesContext.Self∫
4unittest.case._AssertRaisesContext[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException""unittest.case._AssertRaisesContext""unittest.case._AssertRaisesContext*èå
'unittest.case._AssertRaisesContext.Self∫
4unittest.case._AssertRaisesContext[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException""unittest.case._AssertRaisesContext""unittest.case._AssertRaisesContext*Í
__exit__+unittest.case._AssertRaisesContext.__exit__"
builtins.bool"builtins.bool*Ω∫
4unittest.case._AssertRaisesContext[unittest.case._E]^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseException""unittest.case._AssertRaisesContext*çä
(Union[Type[builtins.BaseException],None]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException
None*db
"Union[builtins.BaseException,None]0
builtins.BaseException"builtins.BaseException
None*[Y
Union[types.TracebackType,None]*
types.TracebackType"types.TracebackType
NonePrô
	exception,unittest.case._AssertRaisesContext.exception^
unittest.case._E0
builtins.BaseException"builtins.BaseException"builtins.BaseExceptionœ

_AssertWarnsContext!unittest.case._AssertWarnsContext"builtins.object*Î
	__enter__+unittest.case._AssertWarnsContext.__enter__"ï
&unittest.case._AssertWarnsContext.SelfF
!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext*òï
&unittest.case._AssertWarnsContext.SelfF
!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext*›
__exit__*unittest.case._AssertWarnsContext.__exit__"
None*HF
!unittest.case._AssertWarnsContext"!unittest.case._AssertWarnsContext*çä
(Union[Type[builtins.BaseException],None]R
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException
None*db
"Union[builtins.BaseException,None]0
builtins.BaseException"builtins.BaseException
None*[Y
Union[types.TracebackType,None]*
types.TracebackType"types.TracebackType
Nonerh
warning)unittest.case._AssertWarnsContext.warning2
warnings.WarningMessage"warnings.WarningMessagerT
filename*unittest.case._AssertWarnsContext.filename
builtins.str"builtins.strrP
lineno(unittest.case._AssertWarnsContext.lineno
builtins.int"builtins.intr£
warnings*unittest.case._AssertWarnsContext.warningsk
&builtins.list[warnings.WarningMessage]2
warnings.WarningMessage"warnings.WarningMessage"builtins.list•
addModuleCleanupunittest.case.addModuleCleanup"
None*MK
CallableType[builtins.function]&
builtins.function"builtins.function*

args *
kwargs <
doModuleCleanupsunittest.case.doModuleCleanups"
Noneá
expectedFailureunittest.case.expectedFailure"b
unittest.case._FTK
CallableType[builtins.function]&
builtins.function"builtins.function*q
	test_itemb
unittest.case._FTK
CallableType[builtins.function]&
builtins.function"builtins.functionë
skipunittest.case.skip"K
CallableType[builtins.function]&
builtins.function"builtins.function*(
reason
builtins.str"builtins.str»
skipIfunittest.case.skipIf"K
CallableType[builtins.function]&
builtins.function"builtins.function*1
	condition"
builtins.object"builtins.object*(
reason
builtins.str"builtins.str–

skipUnlessunittest.case.skipUnless"K
CallableType[builtins.function]&
builtins.function"builtins.function*1
	condition"
builtins.object"builtins.object*(
reason
builtins.str"builtins.str*â
__annotations__unittest.case.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*
unittestunittest *H
DIFF_OMITTEDunittest.case.DIFF_OMITTED
builtins.str"builtins.str