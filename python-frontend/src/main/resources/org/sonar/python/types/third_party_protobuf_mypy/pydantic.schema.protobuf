
pydantic.schemaÆ
	SkipFieldpydantic.schema.SkipField"builtins.Exception*•
__init__"pydantic.schema.SkipField.__init__"
None*@
self6
pydantic.schema.SkipField"pydantic.schema.SkipField*)
message
builtins.str"builtins.strrJ
message!pydantic.schema.SkipField.message
builtins.str"builtins.strå
_apply_modify_schema$pydantic.schema._apply_modify_schema"
None*^
modify_schemaK
CallableType[builtins.function]&
builtins.function"builtins.function*y
fieldn
&Union[pydantic.fields.ModelField,None]8
pydantic.fields.ModelField"pydantic.fields.ModelField
None*i
field_schemaW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictÔ
schemapydantic.schema.schema"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*ç
modelsÄ
Ztyping.Sequence[Union[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass]]]ê
IUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModelj
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"typing.Sequence*.
by_alias
builtins.bool"builtins.bool *Q
titleD
Union[builtins.str,None]
builtins.str"builtins.str
None *W
descriptionD
Union[builtins.str,None]
builtins.str"builtins.str
None *V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *0
ref_template
builtins.str"builtins.str ﬁ
model_schemapydantic.schema.model_schema"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*ú
modelê
IUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModelj
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass*.
by_alias
builtins.bool"builtins.bool *V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *0
ref_template
builtins.str"builtins.str Ô
get_field_info_schema%pydantic.schema.get_field_info_schema"±
4Tuple[builtins.dict[builtins.str,Any],builtins.bool]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict
builtins.bool"builtins.bool*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelField*6
schema_overrides
builtins.bool"builtins.bool Ô
field_schemapydantic.schema.field_schema"·
aTuple[builtins.dict[builtins.str,Any],builtins.dict[builtins.str,Any],builtins.set[builtins.str]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelField*.
by_alias
builtins.bool"builtins.bool *≈
model_name_map∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *0
ref_template
builtins.str"builtins.str *ï
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet Í
get_field_schema_validations,pydantic.schema.get_field_schema_validations"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelFieldÇ
get_model_name_map"pydantic.schema.get_model_name_map"∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*î
unique_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet≈	
get_flat_models_from_model*pydantic.schema.get_flat_models_from_model"Ä
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet*`
modelU
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel*ï
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet ¶	
get_flat_models_from_field*pydantic.schema.get_flat_models_from_field"Ä
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelField*ì
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSetÍ	
get_flat_models_from_fields+pydantic.schema.get_flat_models_from_fields"Ä
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet*Ñ
fieldsx
+typing.Sequence[pydantic.fields.ModelField]8
pydantic.fields.ModelField"pydantic.fields.ModelField"typing.Sequence*ì
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSetı
get_flat_models_from_models+pydantic.schema.get_flat_models_from_models"Ä
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet*•
modelsò
.typing.Sequence[Type[pydantic.main.BaseModel]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typing.Sequenceä
get_long_model_name#pydantic.schema.get_long_model_name"
builtins.str"builtins.str*Ø
model£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum´
field_type_schema!pydantic.schema.field_type_schema"·
aTuple[builtins.dict[builtins.str,Any],builtins.dict[builtins.str,Any],builtins.set[builtins.str]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelField*,
by_alias
builtins.bool"builtins.bool*≈
model_name_map∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*.
ref_template
builtins.str"builtins.str*6
schema_overrides
builtins.bool"builtins.bool *V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *ì
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSetÈ
model_process_schema$pydantic.schema.model_process_schema"·
aTuple[builtins.dict[builtins.str,Any],builtins.dict[builtins.str,Any],builtins.set[builtins.str]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*Ø
model£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum*.
by_alias
builtins.bool"builtins.bool *≈
model_name_map∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *0
ref_template
builtins.str"builtins.str *ï
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet *{
fieldn
&Union[pydantic.fields.ModelField,None]8
pydantic.fields.ModelField"pydantic.fields.ModelField
None ê
model_type_schema!pydantic.schema.model_type_schema"·
aTuple[builtins.dict[builtins.str,Any],builtins.dict[builtins.str,Any],builtins.set[builtins.str]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*`
modelU
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel*,
by_alias
builtins.bool"builtins.bool*≈
model_name_map∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*.
ref_template
builtins.str"builtins.str*V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *ì
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSet«
enum_process_schema#pydantic.schema.enum_process_schema"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*5
enum+
Type[enum.Enum]
	enum.Enum"	enum.Enum*{
fieldn
&Union[pydantic.fields.ModelField,None]8
pydantic.fields.ModelField"pydantic.fields.ModelField
None À
!field_singleton_sub_fields_schema1pydantic.schema.field_singleton_sub_fields_schema"·
aTuple[builtins.dict[builtins.str,Any],builtins.dict[builtins.str,Any],builtins.set[builtins.str]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelField*,
by_alias
builtins.bool"builtins.bool*≈
model_name_map∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*.
ref_template
builtins.str"builtins.str*6
schema_overrides
builtins.bool"builtins.bool *V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *ì
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSetÕ
add_field_type_to_schema(pydantic.schema.add_field_type_to_schema"
None*

field_type
Any*d
schema_W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictÌ
get_schema_refpydantic.schema.get_schema_ref"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*&
name
builtins.str"builtins.str*T

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None*.
ref_template
builtins.str"builtins.str*4
schema_overrides
builtins.bool"builtins.boolµ
field_singleton_schema&pydantic.schema.field_singleton_schema"·
aTuple[builtins.dict[builtins.str,Any],builtins.dict[builtins.str,Any],builtins.set[builtins.str]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelField*,
by_alias
builtins.bool"builtins.bool*≈
model_name_map∞
[builtins.dict[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]],builtins.str]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum
builtins.str"builtins.str"builtins.dict*.
ref_template
builtins.str"builtins.str*6
schema_overrides
builtins.bool"builtins.bool *V

ref_prefixD
Union[builtins.str,None]
builtins.str"builtins.str
None *ì
known_modelsÄ
XTypeAlias[builtins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]]É
Mbuiltins.set[TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]]£
?TypeAlias[Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]]º
4Union[Type[pydantic.main.BaseModel],Type[enum.Enum]]U
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel+
Type[enum.Enum]
	enum.Enum"	enum.Enum"pydantic.schema.TypeModelOrEnum"builtins.set"pydantic.schema.TypeModelSetï
#multitypes_literal_field_for_schema3pydantic.schema.multitypes_literal_field_for_schema"8
pydantic.fields.ModelField"pydantic.fields.ModelField*:
values.
builtins.tuple[Any]
Any"builtins.tuple*C
field8
pydantic.fields.ModelField"pydantic.fields.ModelFieldK
encode_defaultpydantic.schema.encode_default"
Any*
dft
Any≤
get_annotation_from_field_info.pydantic.schema.get_annotation_from_field_info"
	Type[Any]
Any*

annotation
Any*F

field_info6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo*,

field_name
builtins.str"builtins.str*9
validate_assignment
builtins.bool"builtins.bool «
get_annotation_with_constraints/pydantic.schema.get_annotation_with_constraints"ë
+Tuple[Type[Any],builtins.set[builtins.str]]
	Type[Any]
AnyH
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*

annotation
Any*F

field_info6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfov
normalize_namepydantic.schema.normalize_name"
builtins.str"builtins.str*&
name
builtins.str"builtins.str*ã
__annotations__pydantic.schema.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*N
default_prefixpydantic.schema.default_prefix
builtins.str"builtins.str*Z
default_ref_template$pydantic.schema.default_ref_template
builtins.str"builtins.str*·
numeric_typespydantic.schema.numeric_types∞
ZTuple[CallableType[builtins.type],CallableType[builtins.type],CallableType[builtins.type]]N
CallableType[builtins.type]
builtins.type"builtins.type"builtins.type?
CallableType[builtins.type]
builtins.type"builtins.type?
CallableType[builtins.type]
builtins.type"builtins.type*Ï
_str_types_attrs pydantic.schema._str_types_attrsµ
cbuiltins.tuple[Tuple[builtins.str,Union[builtins.type,builtins.tuple[builtins.type]],builtins.str]]Ω
STuple[builtins.str,Union[builtins.type,builtins.tuple[builtins.type]],builtins.str]
builtins.str"builtins.strß
2Union[builtins.type,builtins.tuple[builtins.type]]
builtins.type"builtins.typeO
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple
builtins.str"builtins.str"builtins.tuple*Ù
_numeric_types_attrs$pydantic.schema._numeric_types_attrsµ
cbuiltins.tuple[Tuple[builtins.str,Union[builtins.type,builtins.tuple[builtins.type]],builtins.str]]Ω
STuple[builtins.str,Union[builtins.type,builtins.tuple[builtins.type]],builtins.str]
builtins.str"builtins.strß
2Union[builtins.type,builtins.tuple[builtins.type]]
builtins.type"builtins.typeO
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple
builtins.str"builtins.str"builtins.tuple*†
field_class_to_schema%pydantic.schema.field_class_to_schemaﬂ
:builtins.tuple[Tuple[Any,builtins.dict[builtins.str,Any]]]ê
*Tuple[Any,builtins.dict[builtins.str,Any]]
AnyW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict"builtins.tuple*°
json_schemepydantic.schema.json_schemeu
(builtins.dict[builtins.str,builtins.str]
builtins.str"builtins.str
builtins.str"builtins.str"builtins.dict*⁄
_map_types_constraint%pydantic.schema._map_types_constraintô
2builtins.dict[Any,CallableType[builtins.function]]
AnyK
CallableType[builtins.function]&
builtins.function"builtins.function"builtins.dict