
torch.optim.rpropã
Rproptorch.optim.rprop.Rprop"torch.optim.optimizer.Optimizer*ê	
__init__ torch.optim.rprop.Rprop.__init__"
None*<
self2
torch.optim.rprop.Rprop"torch.optim.rprop.Rprop*É
paramsˆ
hTypeAlias[Union[typing.Iterable[torch._tensor.Tensor],typing.Iterable[builtins.dict[builtins.str,Any]]]]Ë
]Union[typing.Iterable[torch._tensor.Tensor],typing.Iterable[builtins.dict[builtins.str,Any]]]f
%typing.Iterable[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"typing.Iterableú
0typing.Iterable[builtins.dict[builtins.str,Any]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict"typing.Iterable"torch.optim.optimizer.ParamsT**
lr 
builtins.float"builtins.float *x
etasl
$Tuple[builtins.float,builtins.float] 
builtins.float"builtins.float 
builtins.float"builtins.float *~

step_sizesl
$Tuple[builtins.float,builtins.float] 
builtins.float"builtins.float 
builtins.float"builtins.float *0

capturable
builtins.bool"builtins.bool *V
foreachG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None *.
maximize
builtins.bool"builtins.bool *4
differentiable
builtins.bool"builtins.bool *I
__setstate__$torch.optim.rprop.Rprop.__setstate__*
self*	
state*ä
_init_group#torch.optim.rprop.Rprop._init_group*
self*	
group*

params*	
grads*	
prevs*

step_sizes*
state_steps*]
steptorch.optim.rprop.Rprop.step*
self*
closure 0:_use_grad_for_differentiableä
_single_tensor_rprop&torch.optim.rprop._single_tensor_rprop"
Any*n
paramsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
prevsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*r

step_sizesb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*3
step_size_min 
builtins.float"builtins.float*3
step_size_max 
builtins.float"builtins.float*.
etaminus 
builtins.float"builtins.float*-
etaplus 
builtins.float"builtins.float*,
maximize
builtins.bool"builtins.bool*.

capturable
builtins.bool"builtins.bool*2
differentiable
builtins.bool"builtins.bool*/
has_complex
builtins.bool"builtins.boolà
_multi_tensor_rprop%torch.optim.rprop._multi_tensor_rprop"
Any*n
paramsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
prevsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*r

step_sizesb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*3
step_size_min 
builtins.float"builtins.float*3
step_size_max 
builtins.float"builtins.float*.
etaminus 
builtins.float"builtins.float*-
etaplus 
builtins.float"builtins.float*,
maximize
builtins.bool"builtins.bool*.

capturable
builtins.bool"builtins.bool*2
differentiable
builtins.bool"builtins.bool*/
has_complex
builtins.bool"builtins.bool*ç
__annotations__!torch.optim.rprop.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*p
__all__torch.optim.rprop.__all__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list