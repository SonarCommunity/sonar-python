
torch.optim.asgdÍ
ASGDtorch.optim.asgd.ASGD"torch.optim.optimizer.Optimizer*Ð
__init__torch.optim.asgd.ASGD.__init__"
None*8
self.
torch.optim.asgd.ASGD"torch.optim.asgd.ASGD*ƒ
paramsö
hTypeAlias[Union[typing.Iterable[torch._tensor.Tensor],typing.Iterable[builtins.dict[builtins.str,Any]]]]è
]Union[typing.Iterable[torch._tensor.Tensor],typing.Iterable[builtins.dict[builtins.str,Any]]]f
%typing.Iterable[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"typing.Iterableœ
0typing.Iterable[builtins.dict[builtins.str,Any]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict"typing.Iterable"torch.optim.optimizer.ParamsT**
lr 
builtins.float"builtins.float *-
lambd 
builtins.float"builtins.float *-
alpha 
builtins.float"builtins.float **
t0 
builtins.float"builtins.float *4
weight_decay 
builtins.float"builtins.float *V
foreachG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None *.
maximize
builtins.bool"builtins.bool *4
differentiable
builtins.bool"builtins.bool *0

capturable
builtins.bool"builtins.bool *G
__setstate__"torch.optim.asgd.ASGD.__setstate__*
self*	
state*“
_init_group!torch.optim.asgd.ASGD._init_group*
self*	
group*
params_with_grad*	
grads*
mus*
axs*
etas*
state_steps*[
steptorch.optim.asgd.ASGD.step*
self*
closure 0:_use_grad_for_differentiable…	
_single_tensor_asgd$torch.optim.asgd._single_tensor_asgd"
Any*n
paramsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*k
axsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*k
musb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*l
etasb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*+
lambd 
builtins.float"builtins.float*(
lr 
builtins.float"builtins.float*(
t0 
builtins.float"builtins.float*+
alpha 
builtins.float"builtins.float*2
weight_decay 
builtins.float"builtins.float*,
maximize
builtins.bool"builtins.bool*2
differentiable
builtins.bool"builtins.bool*.

capturable
builtins.bool"builtins.bool*/
has_complex
builtins.bool"builtins.boolƒ	
_multi_tensor_asgd#torch.optim.asgd._multi_tensor_asgd"
Any*n
paramsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*k
axsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*k
musb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*l
etasb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*+
lambd 
builtins.float"builtins.float*(
lr 
builtins.float"builtins.float*(
t0 
builtins.float"builtins.float*+
alpha 
builtins.float"builtins.float*2
weight_decay 
builtins.float"builtins.float*,
maximize
builtins.bool"builtins.bool*2
differentiable
builtins.bool"builtins.bool*.

capturable
builtins.bool"builtins.bool*/
has_complex
builtins.bool"builtins.bool*Œ
__annotations__ torch.optim.asgd.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*o
__all__torch.optim.asgd.__all__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list