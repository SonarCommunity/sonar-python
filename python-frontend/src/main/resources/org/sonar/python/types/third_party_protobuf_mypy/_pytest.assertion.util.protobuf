
_pytest.assertion.utilå
format_explanation)_pytest.assertion.util.format_explanation"
builtins.str"builtins.str*-
explanation
builtins.str"builtins.str∫
_split_explanation)_pytest.assertion.util._split_explanation"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*-
explanation
builtins.str"builtins.str‹
_format_lines$_pytest.assertion.util._format_lines"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*Y
linesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence_

issequence!_pytest.assertion.util.issequence"
builtins.bool"builtins.bool*
x
AnyW
istext_pytest.assertion.util.istext"
builtins.bool"builtins.bool*
x
AnyW
isdict_pytest.assertion.util.isdict"
builtins.bool"builtins.bool*
x
AnyU
isset_pytest.assertion.util.isset"
builtins.bool"builtins.bool*
x
Anye
isnamedtuple#_pytest.assertion.util.isnamedtuple"
builtins.bool"builtins.bool*
obj
Any_
	isdatacls _pytest.assertion.util.isdatacls"
builtins.bool"builtins.bool*
obj
Any[
isattrs_pytest.assertion.util.isattrs"
builtins.bool"builtins.bool*
obj
Anya

isiterable!_pytest.assertion.util.isiterable"
builtins.bool"builtins.bool*
obj
AnyÑ
has_default_eq%_pytest.assertion.util.has_default_eq"
builtins.bool"builtins.bool*+
obj"
builtins.object"builtins.object÷
assertrepr_compare)_pytest.assertion.util.assertrepr_compare"Å
'Union[builtins.list[builtins.str],None]J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list
None*
config
Any*$
op
builtins.str"builtins.str*
left
Any*
right
Any*/
	use_ascii
builtins.bool"builtins.bool Ÿ
_compare_eq_any&_pytest.assertion.util._compare_eq_any"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*
left
Any*
right
Any*+
verbose
builtins.int"builtins.int ˘

_diff_text!_pytest.assertion.util._diff_text"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*&
left
builtins.str"builtins.str*'
right
builtins.str"builtins.str*+
verbose
builtins.int"builtins.int º
 _surrounding_parens_on_own_lines7_pytest.assertion.util._surrounding_parens_on_own_lines"
None*U
linesJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listµ
_compare_eq_iterable+_pytest.assertion.util._compare_eq_iterable"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*:
left0
typing.Iterable[Any]
Any"typing.Iterable*;
right0
typing.Iterable[Any]
Any"typing.Iterable*+
verbose
builtins.int"builtins.int µ
_compare_eq_sequence+_pytest.assertion.util._compare_eq_sequence"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*:
left0
typing.Sequence[Any]
Any"typing.Sequence*;
right0
typing.Sequence[Any]
Any"typing.Sequence*+
verbose
builtins.int"builtins.int ∑
_compare_eq_set&_pytest.assertion.util._compare_eq_set"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*@
left6
typing.AbstractSet[Any]
Any"typing.AbstractSet*A
right6
typing.AbstractSet[Any]
Any"typing.AbstractSet*+
verbose
builtins.int"builtins.int √
_compare_eq_dict'_pytest.assertion.util._compare_eq_dict"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*E
left;
typing.Mapping[Any,Any]
Any
Any"typing.Mapping*F
right;
typing.Mapping[Any,Any]
Any
Any"typing.Mapping*+
verbose
builtins.int"builtins.int ◊
_compare_eq_cls&_pytest.assertion.util._compare_eq_cls"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*
left
Any*
right
Any*)
verbose
builtins.int"builtins.int˙
_notin_text"_pytest.assertion.util._notin_text"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*&
term
builtins.str"builtins.str*&
text
builtins.str"builtins.str*+
verbose
builtins.int"builtins.int U
running_on_ci$_pytest.assertion.util.running_on_ci"
builtins.bool"builtins.bool*í
__annotations__&_pytest.assertion.util.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*
collectionscollections *
_pytest_pytest *º
_reprcompare#_pytest.assertion.util._reprcompareÜ
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
None*¬
_assertion_pass&_pytest.assertion.util._assertion_passÜ
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
None*ä
_config_pytest.assertion.util._config_
!Union[_pytest.config.Config,None].
_pytest.config.Config"_pytest.config.Config
None