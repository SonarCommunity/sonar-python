
_pytest.pythonŒ


PyobjMixin_pytest.python.PyobjMixin"_pytest.nodes.Node*B
module _pytest.python.PyobjMixin.module*
self0:property`*<
cls_pytest.python.PyobjMixin.cls*
self0:property`*F
instance"_pytest.python.PyobjMixin.instance*
self0:property`*6
_getobj!_pytest.python.PyobjMixin._getobj*
self*˚

getmodpath$_pytest.python.PyobjMixin.getmodpath"
builtins.str"builtins.str*@
self6
_pytest.python.PyobjMixin"_pytest.python.PyobjMixin*2
stopatmodule
builtins.bool"builtins.bool *3
includemodule
builtins.bool"builtins.bool *”

reportinfo$_pytest.python.PyobjMixin.reportinfo"‹
ZTuple[Union[os.PathLike[builtins.str],builtins.str],Union[builtins.int,None],builtins.str]ó
-Union[os.PathLike[builtins.str],builtins.str]F
os.PathLike[builtins.str]
builtins.str"builtins.str"os.PathLike
builtins.str"builtins.strD
Union[builtins.int,None]
builtins.int"builtins.int
None
builtins.str"builtins.str*@
self6
_pytest.python.PyobjMixin"_pytest.python.PyobjMixin2≠
obj_pytest.python.PyobjMixin.obj>
obj_pytest.python.PyobjMixin.obj*
self0:propertyX`G
obj_pytest.python.PyobjMixin.obj*
self*	
value0:
obj.setterrZ
_ALLOW_MARKERS(_pytest.python.PyobjMixin._ALLOW_MARKERS
builtins.bool"builtins.boolr/
_obj_pytest.python.PyobjMixin._obj
Any:
_EmptyClass_pytest.python._EmptyClass"builtins.objectÃ
PyCollector_pytest.python.PyCollector"_pytest.python.PyobjMixin"_pytest.nodes.Collector*«
funcnamefilter)_pytest.python.PyCollector.funcnamefilter"
builtins.bool"builtins.bool*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*&
name
builtins.str"builtins.str*ƒ

isnosetest%_pytest.python.PyCollector.isnosetest"
builtins.bool"builtins.bool*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*+
obj"
builtins.object"builtins.object*…
classnamefilter*_pytest.python.PyCollector.classnamefilter"
builtins.bool"builtins.bool*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*&
name
builtins.str"builtins.str*Ù
istestfunction)_pytest.python.PyCollector.istestfunction"
builtins.bool"builtins.bool*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*+
obj"
builtins.object"builtins.object*&
name
builtins.str"builtins.str*Ó
istestclass&_pytest.python.PyCollector.istestclass"
builtins.bool"builtins.bool*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*+
obj"
builtins.object"builtins.object*&
name
builtins.str"builtins.str*ñ
_matches_prefix_or_glob_option9_pytest.python.PyCollector._matches_prefix_or_glob_option"
builtins.bool"builtins.bool*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*-
option_name
builtins.str"builtins.str*&
name
builtins.str"builtins.str*ﬂ
collect"_pytest.python.PyCollector.collect"Î
Btyping.Iterable[Union[_pytest.nodes.Item,_pytest.nodes.Collector]]ì
1Union[_pytest.nodes.Item,_pytest.nodes.Collector](
_pytest.nodes.Item"_pytest.nodes.Item2
_pytest.nodes.Collector"_pytest.nodes.Collector"typing.Iterable*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*¨
_genfunctions(_pytest.python.PyCollector._genfunctions"o
(typing.Iterator[_pytest.python.Function]2
_pytest.python.Function"_pytest.python.Function"typing.Iterator*B
self8
_pytest.python.PyCollector"_pytest.python.PyCollector*&
name
builtins.str"builtins.str*
funcobj
Any‘
Module_pytest.python.Module"_pytest.nodes.File"_pytest.python.PyCollector*2
_getobj_pytest.python.Module._getobj*
self*–
collect_pytest.python.Module.collect"Î
Btyping.Iterable[Union[_pytest.nodes.Item,_pytest.nodes.Collector]]ì
1Union[_pytest.nodes.Item,_pytest.nodes.Collector](
_pytest.nodes.Item"_pytest.nodes.Item2
_pytest.nodes.Collector"_pytest.nodes.Collector"typing.Iterable*8
self.
_pytest.python.Module"_pytest.python.Module*ñ
_inject_setup_module_fixture2_pytest.python.Module._inject_setup_module_fixture"
None*8
self.
_pytest.python.Module"_pytest.python.Module*ö
_inject_setup_function_fixture4_pytest.python.Module._inject_setup_function_fixture"
None*8
self.
_pytest.python.Module"_pytest.python.Module*F
_importtestmodule'_pytest.python.Module._importtestmodule*
selfã
Package_pytest.python.Package"_pytest.python.Module*Í
__init___pytest.python.Package.__init__"
None*:
self0
_pytest.python.Package"_pytest.python.Package*\
fspathP
$Union[UnboundType[LEGACY_PATH],None]
UnboundType[LEGACY_PATH]
None*>
parent2
_pytest.nodes.Collector"_pytest.nodes.Collector*
config
Any *
session
Any *
nodeid
Any *
path
Any *k
setup_pytest.python.Package.setup"
None*:
self0
_pytest.python.Package"_pytest.python.Package*Ã
gethookproxy#_pytest.python.Package.gethookproxy"
Any*:
self0
_pytest.python.Package"_pytest.python.Package*R
fspathF
os.PathLike[builtins.str]
builtins.str"builtins.str"os.PathLike*∞

isinitpath!_pytest.python.Package.isinitpath"
builtins.bool"builtins.bool*:
self0
_pytest.python.Package"_pytest.python.Package*¢
pathó
-Union[builtins.str,os.PathLike[builtins.str]]
builtins.str"builtins.strF
os.PathLike[builtins.str]
builtins.str"builtins.str"os.PathLike*›
_recurse_pytest.python.Package._recurse"
builtins.bool"builtins.bool*:
self0
_pytest.python.Package"_pytest.python.Package*T
direntryF
os.DirEntry[builtins.str]
builtins.str"builtins.str"os.DirEntry*æ
_collectfile#_pytest.python.Package._collectfile"o
(typing.Sequence[_pytest.nodes.Collector]2
_pytest.nodes.Collector"_pytest.nodes.Collector"typing.Sequence*:
self0
_pytest.python.Package"_pytest.python.Package*(
fspath
pathlib.Path"pathlib.Path*2
handle_dupes
builtins.bool"builtins.bool *”
collect_pytest.python.Package.collect"Î
Btyping.Iterable[Union[_pytest.nodes.Item,_pytest.nodes.Collector]]ì
1Union[_pytest.nodes.Item,_pytest.nodes.Collector](
_pytest.nodes.Item"_pytest.nodes.Item2
_pytest.nodes.Collector"_pytest.nodes.Collector"typing.Iterable*:
self0
_pytest.python.Package"_pytest.python.Package‚
Class_pytest.python.Class"_pytest.python.PyCollector*r
from_parent _pytest.python.Class.from_parent*
cls*

parent*
name*	
obj *
kw0:classmethodp*9
newinstance _pytest.python.Class.newinstance*
self*Õ
collect_pytest.python.Class.collect"Î
Btyping.Iterable[Union[_pytest.nodes.Item,_pytest.nodes.Collector]]ì
1Union[_pytest.nodes.Item,_pytest.nodes.Collector](
_pytest.nodes.Item"_pytest.nodes.Item2
_pytest.nodes.Collector"_pytest.nodes.Collector"typing.Iterable*6
self,
_pytest.python.Class"_pytest.python.Class*ë
_inject_setup_class_fixture0_pytest.python.Class._inject_setup_class_fixture"
None*6
self,
_pytest.python.Class"_pytest.python.Class*ì
_inject_setup_method_fixture1_pytest.python.Class._inject_setup_method_fixture"
None*6
self,
_pytest.python.Class"_pytest.python.Class>
InstanceDummy_pytest.python.InstanceDummy"builtins.objectùU
IdMaker_pytest.python.IdMaker"builtins.object*€
make_unique_parameterset_ids3_pytest.python.IdMaker.make_unique_parameterset_ids"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*ø
_resolve_ids#_pytest.python.IdMaker._resolve_ids"N
typing.Iterable[builtins.str]
builtins.str"builtins.str"typing.Iterable*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*Ä
_idval_pytest.python.IdMaker._idval"
builtins.str"builtins.str*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*+
val"
builtins.object"builtins.object*)
argname
builtins.str"builtins.str*%
idx
builtins.int"builtins.int*ƒ
_idval_from_function+_pytest.python.IdMaker._idval_from_function"D
Union[builtins.str,None]
builtins.str"builtins.str
None*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*+
val"
builtins.object"builtins.object*)
argname
builtins.str"builtins.str*%
idx
builtins.int"builtins.int*ï
_idval_from_hook'_pytest.python.IdMaker._idval_from_hook"D
Union[builtins.str,None]
builtins.str"builtins.str
None*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*+
val"
builtins.object"builtins.object*)
argname
builtins.str"builtins.str*Ï
_idval_from_value(_pytest.python.IdMaker._idval_from_value"D
Union[builtins.str,None]
builtins.str"builtins.str
None*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*+
val"
builtins.object"builtins.object*˝
_idval_from_value_required1_pytest.python.IdMaker._idval_from_value_required"
builtins.str"builtins.str*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*+
val"
builtins.object"builtins.object*%
idx
builtins.int"builtins.int*√
_idval_from_argname*_pytest.python.IdMaker._idval_from_argname"
builtins.str"builtins.str*)
argname
builtins.str"builtins.str*%
idx
builtins.int"builtins.int0:staticmethodh*ü
__init___pytest.python.IdMaker.__init__"
None*:
self0
_pytest.python.IdMaker"_pytest.python.IdMaker*\
argnamesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*¡

parametersets≠

⁄typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]º
…TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]≈
æTuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]Á
Atyping.Sequence[Union[builtins.object,_pytest.compat.NotSetType]]ê
0Union[builtins.object,_pytest.compat.NotSetType]"
builtins.object"builtins.object6
_pytest.compat.NotSetType"_pytest.compat.NotSetType"typing.Sequenceœ
\typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]]€
IUnion[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]N
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"typing.CollectionD
Union[builtins.str,None]
builtins.str"builtins.str
None"$_pytest.mark.structures.ParameterSet"typing.Sequence*ë
idfnÜ
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
None*·
ids◊
8Union[typing.Sequence[Union[builtins.object,None]],None]é
,typing.Sequence[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"typing.Sequence
None*k
config_
!Union[_pytest.config.Config,None].
_pytest.config.Config"_pytest.config.Config
None*P
nodeidD
Union[builtins.str,None]
builtins.str"builtins.str
None*S
	func_nameD
Union[builtins.str,None]
builtins.str"builtins.str
None*Ü
__lt___pytest.python.IdMaker.__lt__"
builtins.bool"builtins.bool*]
selfS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*^
otherS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*Ü
__le___pytest.python.IdMaker.__le__"
builtins.bool"builtins.bool*]
selfS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*^
otherS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*Ü
__gt___pytest.python.IdMaker.__gt__"
builtins.bool"builtins.bool*]
selfS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*^
otherS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*Ü
__ge___pytest.python.IdMaker.__ge__"
builtins.bool"builtins.bool*]
selfS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object*^
otherS
_pytest.python.IdMaker._AT"
builtins.object"builtins.object"builtins.object8r{
argnames_pytest.python.IdMaker.argnamesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.SequencerÂ

parametersets$_pytest.python.IdMaker.parametersets≠

⁄typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]º
…TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]≈
æTuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]Á
Atyping.Sequence[Union[builtins.object,_pytest.compat.NotSetType]]ê
0Union[builtins.object,_pytest.compat.NotSetType]"
builtins.object"builtins.object6
_pytest.compat.NotSetType"_pytest.compat.NotSetType"typing.Sequenceœ
\typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]]€
IUnion[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]N
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"typing.CollectionD
Union[builtins.str,None]
builtins.str"builtins.str
None"$_pytest.mark.structures.ParameterSet"typing.Sequencer¨
idfn_pytest.python.IdMaker.idfnÜ
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
Noner˚
ids_pytest.python.IdMaker.ids◊
8Union[typing.Sequence[Union[builtins.object,None]],None]é
,typing.Sequence[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"typing.Sequence
Nonerà
config_pytest.python.IdMaker.config_
!Union[_pytest.config.Config,None].
_pytest.config.Config"_pytest.config.Config
Nonerm
nodeid_pytest.python.IdMaker.nodeidD
Union[builtins.str,None]
builtins.str"builtins.str
Noners
	func_name _pytest.python.IdMaker.func_nameD
Union[builtins.str,None]
builtins.str"builtins.str
NonerË
__attrs_attrs__&_pytest.python.IdMaker.__attrs_attrs__¨
®Tuple[attr.Attribute[typing.Sequence[builtins.str]],attr.Attribute[typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]],attr.Attribute[Union[CallableType[builtins.function],None]],attr.Attribute[Union[typing.Sequence[Union[builtins.object,None]],None]],attr.Attribute[Union[_pytest.config.Config,None]],attr.Attribute[Union[builtins.str,None]],attr.Attribute[Union[builtins.str,None]]]è
-attr.Attribute[typing.Sequence[builtins.str]]N
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence"attr.Attribute≠
Íattr.Attribute[typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]]≠

⁄typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]º
…TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]≈
æTuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]Á
Atyping.Sequence[Union[builtins.object,_pytest.compat.NotSetType]]ê
0Union[builtins.object,_pytest.compat.NotSetType]"
builtins.object"builtins.object6
_pytest.compat.NotSetType"_pytest.compat.NotSetType"typing.Sequenceœ
\typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]]€
IUnion[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]N
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"typing.CollectionD
Union[builtins.str,None]
builtins.str"builtins.str
None"$_pytest.mark.structures.ParameterSet"typing.Sequence"attr.Attribute÷
;attr.Attribute[Union[CallableType[builtins.function],None]]Ü
+Union[CallableType[builtins.function],None]K
CallableType[builtins.function]&
builtins.function"builtins.function
None"attr.Attribute¥
Hattr.Attribute[Union[typing.Sequence[Union[builtins.object,None]],None]]◊
8Union[typing.Sequence[Union[builtins.object,None]],None]é
,typing.Sequence[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"typing.Sequence
None"attr.Attribute§
1attr.Attribute[Union[_pytest.config.Config,None]]_
!Union[_pytest.config.Config,None].
_pytest.config.Config"_pytest.config.Config
None"attr.AttributeÄ
(attr.Attribute[Union[builtins.str,None]]D
Union[builtins.str,None]
builtins.str"builtins.str
None"attr.AttributeÄ
(attr.Attribute[Union[builtins.str,None]]D
Union[builtins.str,None]
builtins.str"builtins.str
None"attr.Attributeí0
	CallSpec2_pytest.python.CallSpec2"builtins.object*à	
setmulti!_pytest.python.CallSpec2.setmulti"4
_pytest.python.CallSpec2"_pytest.python.CallSpec2*>
self4
_pytest.python.CallSpec2"_pytest.python.CallSpec2*π
valtypes™
Otyping.Mapping[builtins.str,Union[Literal[builtins.str],Literal[builtins.str]]]
builtins.str"builtins.str®
2Union[Literal[builtins.str],Literal[builtins.str]]7
Literal[builtins.str]	
builtins.str"builtins.str7
Literal[builtins.str]	
builtins.str"builtins.str"typing.Mapping*\
argnamesN
typing.Iterable[builtins.str]
builtins.str"builtins.str"typing.Iterable*c
valsetW
 typing.Iterable[builtins.object]"
builtins.object"builtins.object"typing.Iterable*$
id
builtins.str"builtins.str*◊
marksÀ
Ztyping.Iterable[Union[_pytest.mark.structures.Mark,_pytest.mark.structures.MarkDecorator]]€
IUnion[_pytest.mark.structures.Mark,_pytest.mark.structures.MarkDecorator]<
_pytest.mark.structures.Mark"_pytest.mark.structures.MarkN
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator"typing.Iterable*5
scope*
_pytest.scope.Scope"_pytest.scope.Scope*-
param_index
builtins.int"builtins.int*π
getparam!_pytest.python.CallSpec2.getparam""
builtins.object"builtins.object*>
self4
_pytest.python.CallSpec2"_pytest.python.CallSpec2*&
name
builtins.str"builtins.str*ç
id_pytest.python.CallSpec2.id"
builtins.str"builtins.str*>
self4
_pytest.python.CallSpec2"_pytest.python.CallSpec20:property`*°
__init__!_pytest.python.CallSpec2.__init__"
None*>
self4
_pytest.python.CallSpec2"_pytest.python.CallSpec2*é
funcargs~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dict *å
params~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dict *Ñ
indicesu
(builtins.dict[builtins.str,builtins.int]
builtins.str"builtins.str
builtins.int"builtins.int"builtins.dict *ú
	arg2scopeä
/builtins.dict[builtins.str,_pytest.scope.Scope]
builtins.str"builtins.str*
_pytest.scope.Scope"_pytest.scope.Scope"builtins.dict *X
idlistJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list *á
marksz
+builtins.list[_pytest.mark.structures.Mark]<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"builtins.list *å
__lt___pytest.python.CallSpec2.__lt__"
builtins.bool"builtins.bool*_
selfU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*`
otherU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*å
__le___pytest.python.CallSpec2.__le__"
builtins.bool"builtins.bool*_
selfU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*`
otherU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*å
__gt___pytest.python.CallSpec2.__gt__"
builtins.bool"builtins.bool*_
selfU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*`
otherU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*å
__ge___pytest.python.CallSpec2.__ge__"
builtins.bool"builtins.bool*_
selfU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object*`
otherU
_pytest.python.CallSpec2._AT"
builtins.object"builtins.object"builtins.object8r≠
funcargs!_pytest.python.CallSpec2.funcargs~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dictr©
params_pytest.python.CallSpec2.params~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dictr¢
indices _pytest.python.CallSpec2.indicesu
(builtins.dict[builtins.str,builtins.int]
builtins.str"builtins.str
builtins.int"builtins.int"builtins.dictræ

_arg2scope#_pytest.python.CallSpec2._arg2scopeä
/builtins.dict[builtins.str,_pytest.scope.Scope]
builtins.str"builtins.str*
_pytest.scope.Scope"_pytest.scope.Scope"builtins.dictrw
_idlist _pytest.python.CallSpec2._idlistJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listr£
marks_pytest.python.CallSpec2.marksz
+builtins.list[_pytest.mark.structures.Mark]<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"builtins.listrø
__attrs_attrs__(_pytest.python.CallSpec2.__attrs_attrs__Å
ﬂTuple[attr.Attribute[builtins.dict[builtins.str,builtins.object]],attr.Attribute[builtins.dict[builtins.str,builtins.object]],attr.Attribute[builtins.dict[builtins.str,builtins.int]],attr.Attribute[builtins.dict[builtins.str,_pytest.scope.Scope]],attr.Attribute[builtins.list[builtins.str]],attr.Attribute[builtins.list[_pytest.mark.structures.Mark]]]Õ
;attr.Attribute[builtins.dict[builtins.str,builtins.object]]~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dict"attr.AttributeÕ
;attr.Attribute[builtins.dict[builtins.str,builtins.object]]~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dict"attr.Attribute¡
8attr.Attribute[builtins.dict[builtins.str,builtins.int]]u
(builtins.dict[builtins.str,builtins.int]
builtins.str"builtins.str
builtins.int"builtins.int"builtins.dict"attr.Attributeﬁ
?attr.Attribute[builtins.dict[builtins.str,_pytest.scope.Scope]]ä
/builtins.dict[builtins.str,_pytest.scope.Scope]
builtins.str"builtins.str*
_pytest.scope.Scope"_pytest.scope.Scope"builtins.dict"attr.Attributeâ
+attr.Attribute[builtins.list[builtins.str]]J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list"attr.Attribute…
;attr.Attribute[builtins.list[_pytest.mark.structures.Mark]]z
+builtins.list[_pytest.mark.structures.Mark]<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"builtins.list"attr.Attribute’K
Metafunc_pytest.python.Metafunc"builtins.object*ª
__init__ _pytest.python.Metafunc.__init__"
None*<
self2
_pytest.python.Metafunc"_pytest.python.Metafunc*V

definitionF
!_pytest.python.FunctionDefinition"!_pytest.python.FunctionDefinition*U
fixtureinfoD
 _pytest.fixtures.FuncFixtureInfo" _pytest.fixtures.FuncFixtureInfo*:
config.
_pytest.config.Config"_pytest.config.Config*
cls
Any *
module
Any */
	_ispytest
builtins.bool"builtins.bool *˘
parametrize#_pytest.python.Metafunc.parametrize"
None*<
self2
_pytest.python.Metafunc"_pytest.python.Metafunc*≤
argnames£
1Union[builtins.str,typing.Sequence[builtins.str]]
builtins.str"builtins.strN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*˚
	argvaluesÎ
ítyping.Iterable[Union[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]],typing.Sequence[builtins.object],builtins.object]]¬
ÅUnion[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]],typing.Sequence[builtins.object],builtins.object]º
…TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]≈
æTuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]Á
Atyping.Sequence[Union[builtins.object,_pytest.compat.NotSetType]]ê
0Union[builtins.object,_pytest.compat.NotSetType]"
builtins.object"builtins.object6
_pytest.compat.NotSetType"_pytest.compat.NotSetType"typing.Sequenceœ
\typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]]€
IUnion[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]N
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"typing.CollectionD
Union[builtins.str,None]
builtins.str"builtins.str
None"$_pytest.mark.structures.ParameterSetW
 typing.Sequence[builtins.object]"
builtins.object"builtins.object"typing.Sequence"
builtins.object"builtins.object"typing.Iterable*∑
indirect¶
2Union[builtins.bool,typing.Sequence[builtins.str]]
builtins.bool"builtins.boolN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence *–
idsƒ
XUnion[typing.Iterable[Union[builtins.object,None]],CallableType[builtins.function],None]é
,typing.Iterable[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"typing.IterableK
CallableType[builtins.function]&
builtins.function"builtins.function
None *≤
scope§
yUnion[Literal[builtins.str],Literal[builtins.str],Literal[builtins.str],Literal[builtins.str],Literal[builtins.str],None]7
Literal[builtins.str]	
builtins.str"builtins.str7
Literal[builtins.str]	
builtins.str"builtins.str7
Literal[builtins.str]	
builtins.str"builtins.str7
Literal[builtins.str]	
builtins.str"builtins.str7
Literal[builtins.str]	
builtins.str"builtins.str
None *á
_param_markt
(Union[_pytest.mark.structures.Mark,None]<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark
None *˜
_resolve_parameter_set_ids2_pytest.python.Metafunc._resolve_parameter_set_ids"J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*<
self2
_pytest.python.Metafunc"_pytest.python.Metafunc*\
argnamesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*Œ
idsƒ
XUnion[typing.Iterable[Union[builtins.object,None]],CallableType[builtins.function],None]é
,typing.Iterable[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"typing.IterableK
CallableType[builtins.function]&
builtins.function"builtins.function
None*¡

parametersets≠

⁄typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]º
…TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]≈
æTuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]Á
Atyping.Sequence[Union[builtins.object,_pytest.compat.NotSetType]]ê
0Union[builtins.object,_pytest.compat.NotSetType]"
builtins.object"builtins.object6
_pytest.compat.NotSetType"_pytest.compat.NotSetType"typing.Sequenceœ
\typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]]€
IUnion[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]N
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"typing.CollectionD
Union[builtins.str,None]
builtins.str"builtins.str
None"$_pytest.mark.structures.ParameterSet"typing.Sequence*(
nodeid
builtins.str"builtins.str*ç
_validate_ids%_pytest.python.Metafunc._validate_ids"ä
*builtins.list[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"builtins.list*<
self2
_pytest.python.Metafunc"_pytest.python.Metafunc*ò
idsé
,typing.Iterable[Union[builtins.object,None]]M
Union[builtins.object,None]"
builtins.object"builtins.object
None"typing.Iterable*¡

parametersets≠

⁄typing.Sequence[TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]]º
…TypeAlias[Tuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]]≈
æTuple[typing.Sequence[Union[builtins.object,_pytest.compat.NotSetType]],typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]],Union[builtins.str,None]]Á
Atyping.Sequence[Union[builtins.object,_pytest.compat.NotSetType]]ê
0Union[builtins.object,_pytest.compat.NotSetType]"
builtins.object"builtins.object6
_pytest.compat.NotSetType"_pytest.compat.NotSetType"typing.Sequenceœ
\typing.Collection[Union[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]]€
IUnion[_pytest.mark.structures.MarkDecorator,_pytest.mark.structures.Mark]N
%_pytest.mark.structures.MarkDecorator"%_pytest.mark.structures.MarkDecorator<
_pytest.mark.structures.Mark"_pytest.mark.structures.Mark"typing.CollectionD
Union[builtins.str,None]
builtins.str"builtins.str
None"$_pytest.mark.structures.ParameterSet"typing.Sequence*+
	func_name
builtins.str"builtins.str*À
_resolve_arg_value_types0_pytest.python.Metafunc._resolve_arg_value_types"®
Nbuiltins.dict[builtins.str,Union[Literal[builtins.str],Literal[builtins.str]]]
builtins.str"builtins.str®
2Union[Literal[builtins.str],Literal[builtins.str]]7
Literal[builtins.str]	
builtins.str"builtins.str7
Literal[builtins.str]	
builtins.str"builtins.str"builtins.dict*<
self2
_pytest.python.Metafunc"_pytest.python.Metafunc*\
argnamesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*µ
indirect¶
2Union[builtins.bool,typing.Sequence[builtins.str]]
builtins.bool"builtins.boolN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*≤
_validate_if_using_arg_names4_pytest.python.Metafunc._validate_if_using_arg_names"
None*<
self2
_pytest.python.Metafunc"_pytest.python.Metafunc*\
argnamesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*µ
indirect¶
2Union[builtins.bool,typing.Sequence[builtins.str]]
builtins.bool"builtins.boolN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence8rx

definition"_pytest.python.Metafunc.definitionF
!_pytest.python.FunctionDefinition"!_pytest.python.FunctionDefinitionrX
config_pytest.python.Metafunc.config.
_pytest.config.Config"_pytest.config.Configr1
module_pytest.python.Metafunc.module
Anyr5
function _pytest.python.Metafunc.function
AnyrÄ
fixturenames$_pytest.python.Metafunc.fixturenamesJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listr+
cls_pytest.python.Metafunc.cls
AnyrÃ
_arg2fixturedefs(_pytest.python.Metafunc._arg2fixturedefsç
Mbuiltins.dict[builtins.str,typing.Sequence[_pytest.fixtures.FixtureDef[Any]]]
builtins.str"builtins.stré
1typing.Sequence[_pytest.fixtures.FixtureDef[Any]]H
 _pytest.fixtures.FixtureDef[Any]
Any"_pytest.fixtures.FixtureDef"typing.Sequence"builtins.dictrò
_calls_pytest.python.Metafunc._callsn
'builtins.list[_pytest.python.CallSpec2]4
_pytest.python.CallSpec2"_pytest.python.CallSpec2"builtins.list†
Function_pytest.python.Function"_pytest.python.PyobjMixin"_pytest.nodes.Item*π
__init__ _pytest.python.Function.__init__"
None*<
self2
_pytest.python.Function"_pytest.python.Function*&
name
builtins.str"builtins.str*
parent
Any*m
config_
!Union[_pytest.config.Config,None].
_pytest.config.Config"_pytest.config.Config
None *x
callspech
$Union[_pytest.python.CallSpec2,None]4
_pytest.python.CallSpec2"_pytest.python.CallSpec2
None *
callobj
Any *¶
keywordsï
,Union[typing.Mapping[builtins.str,Any],None]Y
 typing.Mapping[builtins.str,Any]
builtins.str"builtins.str
Any"typing.Mapping
None *k
session\
 Union[_pytest.main.Session,None],
_pytest.main.Session"_pytest.main.Session
None *î
fixtureinfoÄ
,Union[_pytest.fixtures.FuncFixtureInfo,None]D
 _pytest.fixtures.FuncFixtureInfo" _pytest.fixtures.FuncFixtureInfo
None *X
originalnameD
Union[builtins.str,None]
builtins.str"builtins.str
None *`
from_parent#_pytest.python.Function.from_parent*
cls*

parent*
kw0:classmethodp*|
_initrequest$_pytest.python.Function._initrequest"
None*<
self2
_pytest.python.Function"_pytest.python.Function*D
function _pytest.python.Function.function*
self0:property`*4
_getobj_pytest.python.Function._getobj*
self*J
_pyfuncitem#_pytest.python.Function._pyfuncitem*
self0:property`*r
runtest_pytest.python.Function.runtest"
None*<
self2
_pytest.python.Function"_pytest.python.Function*n
setup_pytest.python.Function.setup"
None*<
self2
_pytest.python.Function"_pytest.python.Function*°
_prunetraceback'_pytest.python.Function._prunetraceback"
None*<
self2
_pytest.python.Function"_pytest.python.Function*ú
excinfoé
8_pytest._code.code.ExceptionInfo[builtins.BaseException]0
builtins.BaseException"builtins.BaseException" _pytest._code.code.ExceptionInfo*≠
repr_failure$_pytest.python.Function.repr_failure"ô
3Union[builtins.str,_pytest._code.code.TerminalRepr]
builtins.str"builtins.strB
_pytest._code.code.TerminalRepr"_pytest._code.code.TerminalRepr*<
self2
_pytest.python.Function"_pytest.python.Function*ú
excinfoé
8_pytest._code.code.ExceptionInfo[builtins.BaseException]0
builtins.BaseException"builtins.BaseException" _pytest._code.code.ExceptionInforX
_ALLOW_MARKERS&_pytest.python.Function._ALLOW_MARKERS
builtins.bool"builtins.boolrR
originalname$_pytest.python.Function.originalname
builtins.str"builtins.strrb
callspec _pytest.python.Function.callspec4
_pytest.python.CallSpec2"_pytest.python.CallSpec2rz
_fixtureinfo$_pytest.python.Function._fixtureinfoD
 _pytest.fixtures.FuncFixtureInfo" _pytest.fixtures.FuncFixtureInforÄ
fixturenames$_pytest.python.Function.fixturenamesJ
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listr¨
funcargs _pytest.python.Function.funcargs~
+builtins.dict[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"builtins.dictrp
_request _pytest.python.Function._requestB
_pytest.fixtures.FixtureRequest"_pytest.fixtures.FixtureRequest‚
FunctionDefinition!_pytest.python.FunctionDefinition"_pytest.python.Function*ê
runtest)_pytest.python.FunctionDefinition.runtest"
None*P
selfF
!_pytest.python.FunctionDefinition"!_pytest.python.FunctionDefinitionr}
setup'_pytest.python.FunctionDefinition.setupK
CallableType[builtins.function]&
builtins.function"builtins.functionß
<callable subtype of object>+_pytest.python.<callable subtype of object>"builtins.object*I
__call__4_pytest.python.<callable subtype of object>.__call__"
Any™
<callable subtype of object>1,_pytest.python.<callable subtype of object>1"builtins.object*J
__call__5_pytest.python.<callable subtype of object>1.__call__"
Any™
<callable subtype of object>2,_pytest.python.<callable subtype of object>2"builtins.object*J
__call__5_pytest.python.<callable subtype of object>2.__call__"
Anyè
pytest_addoption_pytest.python.pytest_addoption"
None*P
parserD
 _pytest.config.argparsing.Parser" _pytest.config.argparsing.Parserà
pytest_cmdline_main"_pytest.python.pytest_cmdline_main"ê
0Union[builtins.int,_pytest.config.ExitCode,None]
builtins.int"builtins.int2
_pytest.config.ExitCode"_pytest.config.ExitCode
None*:
config.
_pytest.config.Config"_pytest.config.Configâ
pytest_generate_tests$_pytest.python.pytest_generate_tests"
None*@
metafunc2
_pytest.python.Metafunc"_pytest.python.Metafuncy
pytest_configure_pytest.python.pytest_configure"
None*:
config.
_pytest.config.Config"_pytest.config.Configm
async_warn_and_skip"_pytest.python.async_warn_and_skip"
None*(
nodeid
builtins.str"builtins.strá
pytest_collect_file"_pytest.python.pytest_collect_file"_
!Union[_pytest.python.Module,None].
_pytest.python.Module"_pytest.python.Module
None*+
	file_path
pathlib.Path"pathlib.Path*>
parent2
_pytest.nodes.Collector"_pytest.nodes.Collector„
path_matches_patterns$_pytest.python.path_matches_patterns"
builtins.bool"builtins.bool*&
path
pathlib.Path"pathlib.Path*\
patternsN
typing.Iterable[builtins.str]
builtins.str"builtins.str"typing.IterableΩ
pytest_pycollect_makemodule*_pytest.python.pytest_pycollect_makemodule".
_pytest.python.Module"_pytest.python.Module*-
module_path
pathlib.Path"pathlib.Path*
parent
Anyz
_call_with_optional_argument+_pytest.python._call_with_optional_argument"
None*
func
Any*
arg
Any†
_get_first_non_fixture_func*_pytest.python._get_first_non_fixture_func"M
Union[builtins.object,None]"
builtins.object"builtins.object
None*+
obj"
builtins.object"builtins.object*Y
namesN
typing.Iterable[builtins.str]
builtins.str"builtins.str"typing.Iterablem
__getattr___pytest.python.__getattr__""
builtins.object"builtins.object*
builtins.str"builtins.strn
hasinit_pytest.python.hasinit"
builtins.bool"builtins.bool*+
obj"
builtins.object"builtins.objectl
hasnew_pytest.python.hasnew"
builtins.bool"builtins.bool*+
obj"
builtins.object"builtins.objectÏ
_find_parametrized_scope'_pytest.python._find_parametrized_scope"*
_pytest.scope.Scope"_pytest.scope.Scope*\
argnamesN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence*‰
arg2fixturedefsŒ
Ztyping.Mapping[builtins.str,typing.Sequence[_pytest.fixtures.FixtureDef[builtins.object]]]
builtins.str"builtins.str¡
=typing.Sequence[_pytest.fixtures.FixtureDef[builtins.object]]o
,_pytest.fixtures.FixtureDef[builtins.object]"
builtins.object"builtins.object"_pytest.fixtures.FixtureDef"typing.Sequence"typing.Mapping*µ
indirect¶
2Union[builtins.bool,typing.Sequence[builtins.str]]
builtins.bool"builtins.boolN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequenceø
_ascii_escaped_by_config'_pytest.python._ascii_escaped_by_config"
builtins.str"builtins.str*o
valf
"Union[builtins.str,builtins.bytes]
builtins.str"builtins.str 
builtins.bytes"builtins.bytes*k
config_
!Union[_pytest.config.Config,None].
_pytest.config.Config"_pytest.config.Config
Nonel
_pretty_fixture_path#_pytest.python._pretty_fixture_path"
builtins.str"builtins.str*
func
AnyK
show_fixtures_per_test%_pytest.python.show_fixtures_per_test*

config¬
_show_fixtures_per_test&_pytest.python._show_fixtures_per_test"
None*:
config.
_pytest.config.Config"_pytest.config.Config*9
session,
_pytest.main.Session"_pytest.main.SessionÎ
showfixtures_pytest.python.showfixtures"Å
+Union[builtins.int,_pytest.config.ExitCode]
builtins.int"builtins.int2
_pytest.config.ExitCode"_pytest.config.ExitCode*:
config.
_pytest.config.Config"_pytest.config.Config∏
_showfixtures_main!_pytest.python._showfixtures_main"
None*:
config.
_pytest.config.Config"_pytest.config.Config*9
session,
_pytest.main.Session"_pytest.main.SessionÓ
write_docstring_pytest.python.write_docstring"
None*^
twV
)_pytest._io.terminalwriter.TerminalWriter")_pytest._io.terminalwriter.TerminalWriter*%
doc
builtins.str"builtins.str**
indent
builtins.str"builtins.str *ä
__annotations___pytest.python.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*G
_PYTEST_DIR_pytest.python._PYTEST_DIR
pathlib.Path"pathlib.Path*ç
IGNORED_ATTRIBUTES!_pytest.python.IGNORED_ATTRIBUTEST
 builtins.frozenset[builtins.str]
builtins.str"builtins.str"builtins.frozenset