
torch.optim.adadeltaÙ
Adadeltatorch.optim.adadelta.Adadelta"torch.optim.optimizer.Optimizer*∏
__init__&torch.optim.adadelta.Adadelta.__init__"
None*H
self>
torch.optim.adadelta.Adadelta"torch.optim.adadelta.Adadelta*É
paramsˆ
hTypeAlias[Union[typing.Iterable[torch._tensor.Tensor],typing.Iterable[builtins.dict[builtins.str,Any]]]]Ë
]Union[typing.Iterable[torch._tensor.Tensor],typing.Iterable[builtins.dict[builtins.str,Any]]]f
%typing.Iterable[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"typing.Iterableú
0typing.Iterable[builtins.dict[builtins.str,Any]]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict"typing.Iterable"torch.optim.optimizer.ParamsT**
lr 
builtins.float"builtins.float *+
rho 
builtins.float"builtins.float *+
eps 
builtins.float"builtins.float *4
weight_decay 
builtins.float"builtins.float *V
foreachG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None *0

capturable
builtins.bool"builtins.bool *.
maximize
builtins.bool"builtins.bool *4
differentiable
builtins.bool"builtins.bool *O
__setstate__*torch.optim.adadelta.Adadelta.__setstate__*
self*	
state*∂
_init_group)torch.optim.adadelta.Adadelta._init_group"
Any*H
self>
torch.optim.adadelta.Adadelta"torch.optim.adadelta.Adadelta*b
groupW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*x
params_with_gradb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
square_avgsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*r

acc_deltasb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*c
step"torch.optim.adadelta.Adadelta.step*
self*
closure 0:_use_grad_for_differentiableÑ
_single_tensor_adadelta,torch.optim.adadelta._single_tensor_adadelta"
Any*n
paramsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
square_avgsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*r

acc_deltasb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*(
lr 
builtins.float"builtins.float*)
rho 
builtins.float"builtins.float*)
eps 
builtins.float"builtins.float*2
weight_decay 
builtins.float"builtins.float*,
maximize
builtins.bool"builtins.bool*2
differentiable
builtins.bool"builtins.bool*.

capturable
builtins.bool"builtins.bool*/
has_complex
builtins.bool"builtins.boolÇ
_multi_tensor_adadelta+torch.optim.adadelta._multi_tensor_adadelta"
Any*n
paramsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*m
gradsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
square_avgsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*r

acc_deltasb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*s
state_stepsb
#builtins.list[torch._tensor.Tensor],
torch._tensor.Tensor"torch._tensor.Tensor"builtins.list*(
lr 
builtins.float"builtins.float*)
rho 
builtins.float"builtins.float*)
eps 
builtins.float"builtins.float*2
weight_decay 
builtins.float"builtins.float*,
maximize
builtins.bool"builtins.bool*2
differentiable
builtins.bool"builtins.bool*.

capturable
builtins.bool"builtins.bool*/
has_complex
builtins.bool"builtins.bool*ê
__annotations__$torch.optim.adadelta.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*s
__all__torch.optim.adadelta.__all__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list